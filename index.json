{
  "articles/bankid.html": {
    "href": "articles/bankid.html",
    "title": "ActiveLogin.Authentication.BankId | Active Login",
    "keywords": "ActiveLogin.Authentication.BankId ActiveLogin.Authentication enables an application to support Swedish BankID (svenskt BankID) authentication, signing, payments, phone authentication, phone signing and digital ID card verification in .NET. The most common scenario is to use Active Login for BankID auth/login, so most of the concepts will be described from that perspective. We've designed the other features to follow the same patterns and make sure we can share things like certificate handling etc. Table of contents Getting started 1. Preparation 2. Read the documentation 3. Install the NuGet package 3. Prepare your project 4. Get started in development 5. Use test or production environments 6. Monitoring Environments Simulated environment Simulated environment with no config Simulated environment with custom person info Test environment Production environment Full sample for production Sign Payment Basic configuration samples Using client certificate from Azure KeyVault Using client certificate from custom source Adding schemas Customizing schemas Custom schema Customizing BankID options Concepts Storing certificates in Azure Claims Issuing Return URL for cancellation Handle missing or invalid state cookie Multi tenant scenario Customize the UI Simulate BankID API errors Event listeners Store data on auth completion Resolve the end user ip Resolve the end user device data (app or web) Resolve requirements on Auth request Resolve user data on Auth request Custom QR code generation Custom browser detection and launch info Risk indication Verify digital ID card Use api wrapper only Running on Linux Localization Names of the person might be capitalized Cookies issued Browser support Getting started 1. Preparation Certificates BankID requires you to use a client certificate and trust a specific root CA-certificate. Read through the BankID Relying Party Guidelines . This ensures you have a basic understanding of the terminology as well as how the flow and security works. For test: We have (with the permission from BankID) embedded the SSL certificate ( FPTestcert5_20240610.p12 ) in the library. For production: Contact a reseller to get your very own client certificate for production. This will probably take a few business days to get sorted. Please ask for \"Direktupphandlad BankID\" as they otherwise might refer you to a broker/partner. If you haven't decided on using BankID, but want to try it out anyway there are test- and simulation possibilities. See Environments below. The root CA-certificates specified in BankID Relying Party Guidelines (#7 for Production and #8 for Test environment) needs to be trusted at the computer where the app will run. We have (with the permission from BankID) embedded these in the library for easy verification. 2. Read the documentation It is expected that you have a basic understanding of how ASP.NET , ASP.NET MVC and ASP.NET Authentication works before getting started. Active Login is designed to make it very easy to get started with BankID, but in the end you are responsible for making sure that you are compliant with the technical guidelines and/or legal agreements. Therefore, before you start using Active Login, please read the documentation relevant to your needs. This will also make sure you understand the concepts better. BankID (Swedish) BankID (English) 3. Install the NuGet package ActiveLogin.Authentication is distributed as packages on NuGet , install using the tool of your choice, for example dotnet cli . dotnet add package ActiveLogin.Authentication.BankId.AspNetCore 3. Prepare your project The authentication modules for BankID is registered in your Program.cs . Depending on your setup, you will probably have to configure challenge and callbacks in AccountController.cs or similar. For the UI to work, it expects there to be a _Layout.cshtml available so that it can render within at @RenderBody() . The BankID packages have UI is not dependent on any UI library, but the samples uses Bootstrap , please make sure these styles are available in the _Layout.cshtml . Our Samples might give you an inspiration on how to do all these. 4. Get started in development BankID requires you to sign an agreement and receive a certificate used to identity you as a company. To get started and try it out the experience there is a simulated environment options available that uses an in-memory implementation. Great for development and testing. services .AddBankId(bankId => { bankId .AddDebugEventListener() .UseSimulatedEnvironment(); }); services .AddAuthentication() .AddBankIdAuth(bankId => { bankId .AddSameDevice(); }); 5. Use test or production environments To authenticate using a real BankID you need to receive the certificate. See details under Preperation above. Samples on how to use them in production are: services .AddBankId(bankId => { bankId .AddApplicationInsightsEventListener(options => { options.LogUserPersonalIdentityNumberHints = true; }) .UseProductionEnvironment() .UseClientCertificateFromAzureKeyVault(configuration.GetSection(\"ActiveLogin:BankId:ClientCertificate\")) .AddSameDevice() .AddOtherDevice() .UseQrCoderQrCodeGenerator() .UseUaParserDeviceDetection(); }); services .AddAuthentication() .AddBankIdAuth(bankId => { bankId .UseProductionEnvironment(); }); Note: .AddApplicationInsightsEventListener() requires the ActiveLogin.Authentication.BankId.AzureMonitor package. Note: .UseQrCoderQrCodeGenerator() requires the ActiveLogin.Authentication.BankId.QRCoder package. Note: .UseUaParserDeviceDetection() requires the ActiveLogin.Authentication.BankId.UAParser package. 6. Monitoring Active Login provides a structured way of generating and logging events. These coould be monitored to get statistics and health status of your BankID login method. Read more on the topic in Active Login Monitor . Environments Simulated environment For trying out quickly (without the need of certificates) you can use an in-memory implementation of the API by using .UseSimulatedEnvironment() . This could also be good when writing tests. Simulated environment with no config services .AddBankId(bankId => { bankId.UseSimulatedEnvironment(); }); Simulated environment with custom person info The faked name and personal identity number can also be customized like this. services .AddBankId(bankId => { bankId.UseSimulatedEnvironment(\"Alice\", \"Smith\", \"199908072391\") }); Test environment This will use the real REST API for BankID, connecting to the Test environment. It will automatically register both the root and client certificate, even though this behaviour can be disabled. A scenario might be that you want to use the same flow for both test and prod and therefore make sure that fetching the certificate from KeyVault works by trying that out for test. It could also be useful if you are running an older version of Active Login which contains an expired version of the test certificate. You can then disable using the embedded, expired certificate and provide the valid test certificate yourself. BankId provides the client certificate for the test environment in three different versions FPTestcert5_20240610.p12, FPTestcert5_20240610.pem and FPTestcert5_20240610-legacy.pfx. Use FPTestcert5_20240610.p12 for newer applications and environments that support modern encryption methods. Use FPTestcert5_20240610.pem if your application requires PEM format. Use FPTestcert5_20240610-legacy.pfx for older applications requiring older algorithms such as Windows Server earlier versions than 2022. The format of the client certificate can be configured. By default FPTestcert5_20240610-legacy.pfx is used. services .AddBankId(bankId => { bankId.UseTestEnvironment(); }); Disable adding the certificates: services .AddBankId(bankId => { bankId.UseTestEnvironment(useBankIdRootCertificate: false, useBankIdClientCertificate: false); }); Specify client certificate format: services .AddBankId(bankId => { bankId.UseTestEnvironment(clientCertificateFormat: TestCertificateFormat.P12); }); Production environment This will use the real REST API for BankID, connecting to the Production environment. It requires you to have the client certificates described under Preparation above. services .AddBankId(bankId => { bankId.UseProductionEnvironment(); }); Disable adding the root certificates: services .AddBankId(bankId => { bankId.UseProductionEnvironment(useBankIdRootCertificate: false); }); Full sample for production Finally, a full sample on how to use BankID in production with client certificate from Azure KeyVault and trusting a custom root certificate. services .AddBankId(bankId => { .UseProductionEnvironment() .UseClientCertificateFromAzureKeyVault(configuration.GetSection(\"ActiveLogin:BankId:ClientCertificate\")) .UseQrCoderQrCodeGenerator() .UseUaParserDeviceDetection(); }); services .AddAuthentication() .AddBankIdAuth(bankId => { bankId .AddSameDevice() .AddOtherDevice(); }); Sign Sign works very similar to auth, but can't utilize the \"built in\" support for schemes etc. So there are some differences. At first, you need to register both the common BankID logic (environment, cert etc) as well as the sign specific configration (devices). // Add Active Login - BankID services .AddBankId(bankId => { bankId.AddDebugEventListener(); bankId.UseQrCoderQrCodeGenerator(); bankId.UseUaParserDeviceDetection(); bankId.UseSimulatedEnvironment(); }); // Add Active Login - Sign services .AddBankIdSign(bankId => { bankId.AddSameDevice(BankIdSignDefaults.SameDeviceConfigKey, \"BankID (SameDevice)\", options => { }); bankId.AddOtherDevice(BankIdSignDefaults.OtherDeviceConfigKey, \"BankID (OtherDevice)\", options => { }); }); Once that is done you will be able to use these services in your application, for example in your controller: IBankIdSignConfigurationProvider : List the registered configuraitons (SameDevice / Other Device) IBankIdSignService : Initiate and resolve the result of sign flow Here is a minimal sample. See Standalone.MvcSample for more details. [AllowAnonymous] public class SignController : Controller { private readonly IBankIdSignConfigurationProvider _bankIdSignConfigurationProvider; private readonly IBankIdSignService _bankIdSignService; public SignController(IBankIdSignConfigurationProvider bankIdSignConfigurationProvider, IBankIdSignService bankIdSignService) { _bankIdSignConfigurationProvider = bankIdSignConfigurationProvider; _bankIdSignService = bankIdSignService; } public async Task<IActionResult> Index() { var configurations = await _bankIdSignConfigurationProvider.GetAllConfigurationsAsync(); var providers = configurations .Where(x => x.DisplayName != null) .Select(x => new ExternalProvider(x.DisplayName ?? x.Key, x.Key)); var viewModel = new BankIdViewModel(providers, \"~/\"); return View(viewModel); } public IActionResult Sign(string provider) { var props = new BankIdSignProperties(\"The info displayed for the user\") // The user visible data { UserNonVisibleData = new byte[1024], // Whataver data you want to sign UserVisibleDataFormat = BankIdUserVisibleDataFormats.SimpleMarkdownV1, // The format of the user visible data, use empty or the markwodn constant Items = { {\"returnUrl\", \"~/\"}, {\"scheme\", provider} } RequirePinCode = true, RequireMrtd = true RequiredPersonalIdentityNumber = new PersonalIdentityNumber(1999, 8, 7, 239, 1) }; var returnPath = $\"{Url.Action(nameof(Callback))}?provider={provider}\"; return this.BankIdInitiateSign(props, returnPath, provider); } [HttpPost] public async Task<IActionResult> Callback(string provider) { var result = await _bankIdSignService.GetSignResultAsync(provider); if (result?.Succeeded != true) { throw new Exception(\"Sign error\"); } // Parse these to store the signed values var ocspResponse = result.BankIdCompletionData?.OcspResponse; var signature = result.BankIdCompletionData?.Signature; return Redirect(result.Properties?.Items[\"returnUrl\"] ?? \"~/\"); } } Payment Payment works very similar to sign and auth. You need to register both the common BankID logic (environment, cert etc) as well as the payment specific configration (devices). // Add Active Login - BankID services .AddBankId(bankId => { bankId.AddDebugEventListener(); bankId.UseQrCoderQrCodeGenerator(); bankId.UseUaParserDeviceDetection(); bankId.UseSimulatedEnvironment(); }); // Add Active Login - Payment services.AddBankIdPayment(bankId => { bankId.AddSameDevice(BankIdPaymentDefaults.SameDeviceConfigKey, \"BankID (SameDevice)\", options => { }); bankId.AddOtherDevice(BankIdPaymentDefaults.OtherDeviceConfigKey, \"BankID (OtherDevice)\", options => { }); }); Once that is done you will be able to use these services in your application, for example in your controller: IBankIdPaymentConfigurationProvider : List the registered configuraitons (Same Device / Other Device) IBankIdPaymentService : Initiate and resolve the result of payment flow Here is a minimal sample. See Standalone.MvcSample for more details. [AllowAnonymous] public class PaymentController : Controller { private readonly IBankIdPaymentConfigurationProvider _bankIdPaymentConfigurationProvider; private readonly IBankIdPaymentService _bankIdPaymentService; public PaymentController(IBankIdPaymentConfigurationProvider bankIdPaymentConfigurationProvider, IBankIdPaymentService bankIdPaymentService) { _bankIdPaymentConfigurationProvider = bankIdPaymentConfigurationProvider; _bankIdPaymentService = bankIdPaymentService; } public async Task<IActionResult> Index() { var configurations = await _bankIdPaymentConfigurationProvider.GetAllConfigurationsAsync(); var providers = configurations .Where(x => x.DisplayName != null) .Select(x => new ExternalProvider(x.DisplayName ?? x.Key, x.Key)); var viewModel = new BankIdViewModel(providers, $\"{Url.Action(nameof(Index))}\"); return View(viewModel); } [AllowAnonymous] [HttpPost(\"Payment\")] public IActionResult Payment([FromQuery] string provider, [FromForm] PaymentRequestModel model) { ArgumentNullException.ThrowIfNull(model, nameof(model)); var recipientName = \"Demo Merchant Name\"; var amount = \"100,00\"; var currency = \"SEK\"; var props = new BankIdPaymentProperties(TransactionType.card, recipientName) { Money = new(amount, currency), UserVisibleData = \"Demo of Payment with Active Login.\", Items = { {\"scheme\", provider}, {\"transactionType\", nameof(TransactionType.card)}, {\"recipientName\", recipientName}, {\"amount\", amount}, {\"currency\", currency} }, }; var returnPath = $\"{Url.Action(nameof(Callback))}?provider={provider}\"; return this.BankIdInitiatePayment(props, returnPath, provider); } [AllowAnonymous] [HttpPost] public async Task<IActionResult> Callback(string provider) { var result = await _bankIdPaymentService.GetPaymentResultAsync(provider); if (result?.Succeeded != true || result.BankIdCompletionData == null) { throw new Exception(\"Payment error\"); } return View(\"Result\", new PaymentResultViewModel( result.BankIdCompletionData.User.PersonalIdentityNumber, result.BankIdCompletionData.User.Name, result.BankIdCompletionData.Device.IpAddress, result.Properties.Items[\"transactionType\"] ?? string.Empty, result.Properties.Items[\"recipientName\"] ?? string.Empty, result.Properties.Items[\"amount\"] ?? null, result.Properties.Items[\"currency\"] ?? null ) ); } } Basic configuration samples Using client certificate from Azure KeyVault services.AddBankId(bankId => { bankId .UseProductionEnvironment() .UseClientCertificateFromAzureKeyVault(configuration.GetSection(\"ActiveLogin:BankId:ClientCertificate\")) ... }); Using client certificate from custom source services.AddBankId(bankId => { bankId .UseProductionEnvironment() .UseClientCertificate(() => new X509Certificate2( ... )) ... }); Using client certificate from custom certificate service services.AddBankId(bankId => { bankId .UseProductionEnvironment() .UseClientCertificate(sp => sp.GetRequiredService<MyCustomCertificateService>().GetCertificate()) ... }); Adding schemas Same device : Launches the BankID app on the same device, no need to enter any personal identity number. Other device : The user manually launches the app the smartphone and scans the QR code. services .AddAuthentication() .AddBankIdAuth(bankId => { bankId .AddSameDevice() .AddOtherDevice(); }); Customizing schemas By default, Add*Device will use predefined schemas and display names, but they can be changed. services .AddAuthentication() .AddBankIdAuth(bankId => { bankId .AddSameDevice(\"custom-auth-scheme\", \"Custom display name\", options => { ... }) .AddOtherDevice(BankIdDefaults.OtherDeviceAuthenticationScheme, \"Custom display name\", options => { ... }); }); Customizing BankID options BankId options allows you to set and override some options such as the below requirements on how the authentication or signature order must be performed. .AddOtherDevice(options => { // If the client needs to provide MRTD (Machine readable travel document) information to complete the order. // Only Swedish passports and national ID cards are supported. options.BankIdRequireMrtd = true; // Users are required to sign the transaction with their PIN code, even if they have biometrics activated. options.BankIdRequirePinCode = true; // Limit possible login methods to, for example, only allow BankID on smartcard. // If no policy is set, it will fall back to require mobile BankID for OtherDevice flow options.BankIdCertificatePolicies = [ BankIdCertificatePolicy.BankIdOnFile, BankIdCertificatePolicy.BankIdOnSmartCard ]; // If set to true a risk indication is requested from BankID and returned as part of the collect response. options.BankIdReturnRisk = true; }); If you want to apply some options for all BankID schemes, you can do so by using .Configure<BankIdAuthOptions>(...) . .Configure<BankIdAuthOptions>(options => { options.BankIdRequireMrtd = true; options.BankIdReturnRisk = true; }); Requirements can also be set dynamically for each authentication, see section Resolve requirements on Auth request . To use dynamic requirements with signatures provide the requirements as part the BankIdSignProperties , see section Sign . To use dynamic requirements with payments provide the requirements as part the BankIdPaymentProperties , see section Payment . Concepts Storing certificates in Azure These are only necessary if you plan to store your certificates in Azure KeyVault (recommended) and use the extension for easy integration with BankID. Deploy Azure KeyVault to your subscription. The ARM-template available in AzureProvisioningSample contains configuration that creates a KeyVault and enables Managed Service Identity for the App Service. Import the certificates to your Azure Key Vault. Add the following to your config, the secret identifier and auth settings. { \"ActiveLogin:BankId:ClientCertificate\": { \"AzureKeyVaultUri\": \"TODO-ADD-YOUR-VALUE\", \"AzureKeyVaultSecretName\": \"TODO-ADD-YOUR-VALUE\" } } Certificates are secrets When configuring the AzureKeyVaultSecretName, the name is retrieved from the Certificates rather than Secrets in the Azure Portal. It is called a secret in the API since this is how Azure Key Vault exposes certificates with private keys. You can read more about the reasoning behind this in this blog post or in the very extensive official documentation . KeyVault credentials By default, the DefaultAzureCredential will be used as credentials. For info on how to use that, see Microsoft docs . The minimal configuration then looks like this: { \"ActiveLogin:BankId:ClientCertificate\" { \"AzureKeyVaultUri\": \"TODO-ADD-YOUR-VALUE\", \"AzureKeyVaultSecretName\": \"TODO-ADD-YOUR-VALUE\" } } You can override the specific managed identity client id to use: { \"ActiveLogin:BankId:ClientCertificate\" { \"AzureKeyVaultUri\": \"TODO-ADD-YOUR-VALUE\", \"AzureKeyVaultSecretName\": \"TODO-ADD-YOUR-VALUE\", \"AzureManagedIdentityClientId\": \"\" } } You can also override to use client credentials: { \"ActiveLogin:BankId:ClientCertificate\" { \"AzureKeyVaultUri\": \"TODO-ADD-YOUR-VALUE\", \"AzureKeyVaultSecretName\": \"TODO-ADD-YOUR-VALUE\", \"AzureAdTenantId\": \"\", \"AzureAdClientId\": \"\", \"AzureAdClientSecret\": \"\" } } They will be evaluated in the order: ClientSecretCredential with AzureAdTenantId + AzureAdClientId + AzureAdClientSecret (if specified) DefaultAzureCredential with AzureManagedIdentityClientId (if specified) DefaultAzureCredential Claims Issuing Active Login aims to issue the most relevant claims that can be extracted from the information provided by BankID. There are scenarios where you might like to change issued claims or add new ones yourself. We've made the claims issuing pipeline pluggable so you can add your own transformer. All of the default claims behaviour are implemented in BankIdDefaultClaimsTransformer and this is the only transformer added by default. Implementing IBankIdClaimsTransformer You are also able to create your own transformer by inheriting it from the interface IBankIdClaimsTransformer . BankIdClaimsTransformationContext will contain the relevant context, and also the already issued list of claims that you can transform. Once implemented, register your implementation using: services .AddAuthentication() .AddBankIdAuth(bankId => { bankId.AddSameDevice(); bankId.AddClaimsTransformer<BankIdYourCustomClaimsTransformer>(); }); The claims beeing issued by default have the names/keys specified in the public class BankIdClaimTypes so you can refer to them by these constants. Example: Add orderref as txn claim If the application that uses ActiveLogin BankId needs to keep an audit trail of the sign-in, the txn claim could preferably be used for this. From OpenId Connect for Identity Assurance : The txn Claim as defined in [RFC8417] is used in the context of this extension to build audit trails across the parties involved in an OpenID Connect transaction. public class BankIdTxnClaimsTransformer : IBankIdClaimsTransformer { public Task TransformClaims(BankIdClaimsTransformationContext context) { context.AddClaim(\"txn\", context.BankIdOrderRef); return Task.CompletedTask; } } Note: If the txn claim is issued, you are responsible for making sure to keep relevant audit informaiton given that session. See the OpenId Connect spec linked above for more information. Example: Add birthdate and gender claims It is possible to extract some information from the swedish personal identity number. In previous versions of Active Login this was a built in feature, but is now removed from the default set of claims beeing issued. If you still are interested in such functionality, you can easily implement the functionality using the code below. See information on the limitations of hint information in the ActiveLogin.Identity readme . public class BankIdPinHintClaimsTransformer : IBankIdClaimsTransformer { private const string GenderJwtType = \"gender\"; private const string BirthdateJwtType = \"birthdate\"; public Task TransformClaims(BankIdClaimsTransformationContext context) { var personalIdentityNumber = PersonalIdentityNumber.Parse(context.PersonalIdentityNumber); // Add gender from gender hint // See https://github.com/ActiveLogin/ActiveLogin.Identity#hints for limitations var jwtGender = GetJwtGender(personalIdentityNumber.GetGenderHint()); if (!string.IsNullOrEmpty(jwtGender)) { context.AddClaim(GenderJwtType, jwtGender); } // Add birthdate from birthdate hint // See https://github.com/ActiveLogin/ActiveLogin.Identity#hints for limitations var jwtBirthdate = GetJwtBirthdate(personalIdentityNumber.GetDateOfBirthHint()); context.AddClaim(BirthdateJwtType, jwtBirthdate); return Task.CompletedTask; } private static string GetJwtGender(Gender gender) { // Specified in: http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.5.1 return gender switch { Gender.Female => \"female\", Gender.Male => \"male\", _ => string.Empty, }; } private static string GetJwtBirthdate(DateTime birthdate) { // Specified in: http://openid.net/specs/openid-connect-core-1_0.html#rfc.section.5.1 return birthdate.Date.ToString(\"yyyy-MM-dd\"); } } Return URL for cancellation If a user cancels the login, the user will be redirected to the cancelReturnUrl . The defaults for cancellation are as follows: Same Device Scheme returns to scheme selection Other Device Scheme returns to scheme selection when using QR codes It is possible to override the default navigation when cancelling an authentication request. The URL used for navigation is set through the cancelReturnUrl item in the AuthenticationProperties passed in the authentication challenge. var props = new AuthenticationProperties { RedirectUri = Url.Action(nameof(ExternalLoginCallback)), Items = { { \"returnUrl\", \"~/\" }, { \"cancelReturnUrl\", \"~/some-custom-cancellation-url\" }, { \"scheme\", provider } } }; return Challenge(props, provider); Handle missing or invalid state cookie If the user navigates directly to the BankdID status page ( /ActiveLogin/BankId/Auth ) the state cookie ( __ActiveLogin.BankIdState ) will be missing. If that happens, the flow will fail. By default, the user will be redirected back to the cancelReturnUrl , see Setting the return URL for cancellation . This behaviour can be overriden by implementing IBankIdInvalidStateHandler and adding that to the IOC-container. A simple sample of such handler is: public class SampleInvalidStateHandler : IBankIdInvalidStateHandler { public Task HandleAsync(HttpContext httpContext, BankIdInvalidStateContext invalidStateContext) { httpContext.Response.StatusCode = StatusCodes.Status500InternalServerError; return Task.CompletedTask; } } Multi tenant scenario With the current architecture of Active Login all services are registered \"globally\" and you can't call .AddBankId() more than once. To run Active Login in a multi tenant scenario, where different customers should use different certificates, you could register multiple certificates and on runtime select the correct one per request. To register multiple certificates you need to use the .AddClientCertificate...() instead of .UseClientCertificate...() as the .Use...() version will overwrite any existing certificates registered with the http client handler. With our current solution, this requires you to disable pooling of the SocketsHttpHandler so we've decided not to ship that code in the NuGet-package, but below you'll find a sample on how it could be configured. We hope to redesign this in the future. Note: The code below is a sample and because it disables PooledConnection it might (and will) have performance implications. internal static class BankIdBuilderExtensions { public static IBankIdBuilder UseClientCertificateResolver(this IBankIdBuilder builder, Func<ServiceProvider, X509CertificateCollection, string, X509Certificate> configureClientCertificateResolver) { builder.ConfigureHttpClientHandler((serviceProvider, httpClientHandler) => { httpClientHandler.PooledConnectionLifetime = TimeSpan.Zero; httpClientHandler.SslOptions.LocalCertificateSelectionCallback = (sender, host, certificates, certificate, issuers) => configureClientCertificateResolver(serviceProvider, certificates, host); }); return builder; } } public class Startup { public void ConfigureServices(IServiceCollection services) { // ... services .AddBankId(bankId => { bankId .AddClientCertificateFromAzureKeyVault(configuration.GetSection(\"ActiveLogin:BankId:ClientCertificate1\")) .AddClientCertificateFromAzureKeyVault(configuration.GetSection(\"ActiveLogin:BankId:ClientCertificate2\")) .AddClientCertificateFromAzureKeyVault(configuration.GetSection(\"ActiveLogin:BankId:ClientCertificate3\")) .UseClientCertificateResolver((serviceCollection, certificates, hostname) => { // Apply logic here to select the correct certificate return certificates[0]; }); // ... } } } Customize the UI Active Login comes with predefined views that you can use, but maybe you'd rather use your own views to customize layout or behavior. The UI is bundled into the package as a Razor Class Library, a technique that allows to override the parts you want to customize . The Views and Controllers that can be customized can be found in the GitHub repo . To override the default UI your web project, create the following folder: Areas/ActiveLogin/Views/Shared In this folder, you can then create any of the partials and MVC will then discover your partials and use any of them before ours. It's still possible to call our partials if you still want to use them. Init.cshtml _Wrapper.cshtml _Form.cshtml _Status.cshtml _Script.cshtml _Style.cshtml _Spinner.cshtml If you want, you can override the UI for Auth, Sign and Payment with different templates. Do so by placing the files in one of these folders: Areas/ActiveLogin/Views/BankIdUiAuth Areas/ActiveLogin/Views/BankIdUiSign Areas/ActiveLogin/Views/BankIdUiPayment See the MVC sample to see this in action, as demonstrated here . Simulate BankID API errors When developing and testing your application, it can be useful to simulate various BankID API errors to ensure your application handles them gracefully. ActiveLogin provides a way to simulate these errors in any environment. The BankIdBuilder has an extension method AddSimulatedBankIdApiError that can be used to simulate errors. The method takes the parameters: errorRate : The rate of errors to simulate, a value between 0 and 1. For example, 0.5 will simulate an error in 50% of the requests. errors : The errors that will be used to simulate. The errors are defined in a Dictionary with the key being an ErrorCod e Enum and the value being the ErrorDescription. varyErrorTypes : If true, the error type will be varied between the errors in the list. If false, the same random error type will be used for all API calls. Simulated API error usage The example below will fail 20% of the API calls to BankId with either a RequestTimeout or InternalError. The error type will be varied between the errors. services .AddBankId(bankId => { bankId.UseSimulatedEnvironment(); bankId.AddSimulatedApiErrors( errorRate: 0.2, errors: new Dictionary<ErrorCode, string>() { { ErrorCode.RequestTimeout, \"Timeout in API\" }, { ErrorCode.InternalError, \"Internal error in API\" } }, varyErrorTypes: true); }); Event listeners During the login flow, quite a lot of things are happening and using our event listeners you can listen and act on those events. By implementing and regestering IBankIdEventListener you will be notified when an event occurs. A common scenario is logging. Multiple event listeners can be registered. BankIdEvent is the base class for all events which all events will inherit from. Each event might (and in most cases will) have unique properties relevant for that specific event. Event types At the moment, we trigger the events listed below. They all have unique event properties relevant to the event type. AspNet BankIdAspNetChallengeSuccessEvent BankIdAspNetAuthenticateSuccessEvent BankIdAspNetAuthenticateFailureEvent Initialize BankIdInitializeSuccessEvent BankIdInitializeErrorEvent Sign BankIdSignSuccessEvent BankIdSignFailureEvent Payment BankIdPaymentSuccessEvent BankIdPaymentFailureEvent Collect BankIdCollectPendingEvent BankIdCollectCompletedEvent BankIdCollectFailureEvent BankIdCollectErrorEvent Cancel BankIdCancelSuccessEvent BankIdCancelErrorEvent Sample implementation public class BankIdSampleEventListener : IBankIdEventListener { public Task HandleAsync(BankIdEvent bankIdEvent) { Console.WriteLine($\"{bankIdEvent.EventTypeName}: {bankIdEvent.EventSeverity}\"); return Task.CompletedTask; } } services .AddBankId(bankId => { bankId.AddEventListener<BankIdSampleEventListener>(); }); Built in event listeners BankIdDebugEventListener BankIdDebugEventListener will listen for all events and write them as serialized JSON to the debug log using ILogger.LogDebug(...) . Call bankId.AddDebugEventListener() to enable it. Good to have for local development to see all details about what is happening. services .AddBankId(bankId => { bankId.AddDebugEventListener(); }); BankIdApplicationInsightsEventListener BankIdApplicationInsightsEventListener will listen for all events and write them to Application Insights. Call bankId.AddApplicationInsightsEventListener() to enable it. Note that you can supply options to enable logging of metadata, such as personal identity number, age and IP. Note: This event listener is available is available through a separate package called ActiveLogin.Authentication.BankId.AzureMonitor . services .AddBankId(bankId => { bankId.AddApplicationInsightsEventListener(); }); By default it will use whatever InstrumentationKey is registered with the application. There are overloads available so you can customize this: services .AddBankId(bankId => { bankId.AddApplicationInsightsEventListener(\"CUSTOM_CONNECTION_STRING\"); }); You can also customize what kind of data should be logged together with the Application Insight events. For example: services .AddBankId(bankId => { bankId.AddApplicationInsightsEventListener(options => { options.LogUserPersonalIdentityNumber = false; options.LogUserPersonalIdentityNumberHints = true; options.LogUserNames = false; options.LogDeviceIpAddress = false; options.LogDeviceUniqueHardwareId = true; options.LogUserBankIdIssueDate = true; // And more... }); }); BankIdLoggerEventListener BankIdLoggerEventListener will listen for all events and write them with a descriptive text to the log using ILogger.Log(...) . This listener is registered by default on startup, se info below if you want to clear the default listeners. Default registered event listeners By default, two event listeners will be enabled: BankIdLoggerEventListener (Log all events to ILogger ) BankIdResultStoreEventListener (Map the completion event for IBankIdResultStore , see info below under Store data on auth completion .) If you want to remove those implementations, remove any class implementing IBankIdEventListener from the ASP.NET Core services in your Startup.cs : services.RemoveAll(typeof(IBankIdEventListener)); Store data on auth completion When the login flow is completed and the collect request to BankID returns data, any class implementing IBankIdResultStore registered in the DI will be called. There is a shorthand method ( AddResultStore ) on the BankIdBuilder to register the implementation. Note: IBankIdResultStore is just a shorthand for the BankIdCollectCompletedEvent as described above. Sample implementation: public class BankIdResultSampleLoggerStore : IBankIdResultStore { private readonly EventId _eventId = new EventId(101, \"StoreCollectCompletedCompletionData\"); private readonly ILogger<BankIdResultTraceLoggerStore> _logger; public BankIdResultSampleLoggerStore(ILogger<BankIdResultTraceLoggerStore> logger) { _logger = logger; } public Task StoreCollectCompletedCompletionData(string orderRef, CompletionData completionData) { _logger.LogTrace(_eventId, \"Storing completion data for OrderRef '{OrderRef}' (UserPersonalIdentityNumber: '{UserPersonalIdentityNumber}')\", orderRef, completionData.User.PersonalIdentityNumber); return Task.CompletedTask; } } services .AddBankId(bankId => { bankId.AddResultStore<BankIdResultSampleLoggerStore>(); }); The default implementation will log all data to the tracelog. If you want to remove that implementation, remove any class implementing IBankIdResultStore from the ASP.NET Core services in your Startup.cs : services.RemoveAll(typeof(IBankIdResultStore)); Resolve the end user ip In some scenarios, like running behind a proxy, you might want to resolve the end user IP yourself and override the default implementation. Either register a class implementing IBankIdEndUserIpResolver : services.AddTransient<IBankIdEndUserIpResolver, EndUserIpResolver>(); Resolve the end user device data (app or web) When initiating a flow with BankID, you can include either the web parameter (for web applications ) or the app parameter (for mobile apps ) in the request. In Active Login, these parameters are collectively referred to as device data . The metadata included with these parameters differs depending on the device type, but providing either one allows BankID to deliver a more accurate Risk indication . Risk Indication provides an estimated risk level for a BankID transaction. It is a way to enhance the security of your application by, for example, requiring additional controls such as ID card validation for transactions that are assessed as high risk. Configuring Device Data Active Login provides a default implementation of the Device Data feature that assumes it is running from a web application . You can either customize this default implementation or create your own for other device types. The following service interface must be implemented to use the Device Data feature: IBankIdEndUserDeviceDataResolverFactory : Factory that provides the resolvers for the device type. IBankIdEndUserDeviceDataResolver : Resolver that provides the device data for a given device type. IBankIdEndUserDeviceDataConfiguration : Configuration that specifies the device type to use. What is included in the requests? Device Type Default Resolver Implementation Metadata Included Web BankIdDefaultEndUserWebDeviceDataResolver Referring Domain, User-Agent, Device Identifier App No resolver is configured by default for mobile apps. App Identifier, Device OS, Model, Device Identifier The Device Identifier , included in both the web and app parameters, must remain identical across requests. For web applications , the Device Identifier should be unique to the user's browser and must not rely on a session cookie, it can be stored in a separate cookie or as a hash of one. The BankIdDefaultEndUserWebDeviceDataResolver sets a protected cookie named __ActiveLogin.BankIdDeviceData containing a unique Device Identifier . This ensures that the identifier persists across sessions and requests. For mobile apps , the Device Identifier uniquely identifies the device your client is running on. It should not be tied to a single user of the device and ideally should remain the same even if the app is reinstalled. Note: Cookies are protected using ASP.NET Core Data Protection. For more information about the cookies used by the package, including how they are protected and considerations for persistent key storage, see the Cookies issued section above. This is important, especially in distributed environments. Customizing the Device Data feature To customize the Device Data feature, use the UseDeviceData extension in the BankID client builder. This allows you to specify the device type and any relevant metadata using resolvers. The BankIdFlowService will automatically include the device data in the BankID request, since it is dependent of the IBankIdEndUserDeviceDataResolverFactory service. Configuration examples If no configuration of the UseDeviceData has been set, the default implementation will be used. This implementation will set the device type to BankIdEndUserDeviceType.Web and use the BankIdDefaultEndUserDeviceDataResolverFactory to find the correct resolver for the device type. The BankIdDefaultEndUserWebDeviceDataResolver is used to fetch the web browser information. If no custom implementation is made the device data defaults to this: services .AddBankId(bankId => { bankId.UseDeviceData(config => { // Set the device type for the request config.DeviceType = BankIdEndUserDeviceType.Web; // Use the default resolver factory config.UseResolverFactory<BankIdDefaultEndUserDeviceDataResolverFactory>(); // Add the default resolver for Web config.UseDeviceResolver<BankIdDefaultEndUserWebDeviceDataResolver>(); }); }); Custom implementation requests initiated by av web browser: services .AddBankId(bankId => { bankId.UseDeviceData(config => { // Set the device type for the request config.DeviceType = BankIdEndUserDeviceType.Web; // Use a custom resolver factory // that implements IBankIdEndUserDeviceDataResolverFactory config.UseResolverFactory<MyCustomResolverFactory>(); // Add a custom resolver for the device type Web // that implements IBankIdEndUserDeviceDataResolver config.UseDeviceResolver<MyCustomWebDeviceDataResolver>(); }); }); Custom implementation requests initiated by a mobile app: services .AddBankId(bankId => { bankId.UseDeviceData(config => { // Set the device type starting the request config.DeviceType = BankIdEndUserDeviceType.App; // Use the default resolver factory to find what device data resolvers to use config.UseResolverFactory<BankIdDefaultEndUserDeviceDataResolverFactory>(); // Use the default data resolver for the device type app // On app devices (e.g. MAUI, Xamarin, etc.) we need to set the // device data manually at start config.UseDeviceResolver<IBankIdEndUserDeviceDataResolver>(_ => new BankIdAppDeviceDataResolver() { // App ID or package name AppIdentifier = \"com.example.app\", // Device operating system DeviceOs = \"iOS 16.7.7\", // Device model DeviceModelName = \"Apple iPhone14,3\", // Unique hardware ID DeviceIdentifier = \"1234567890\" }); }); }); The information for the BankIdAppDeviceDataResolver must be configured during application startup. You can also provide your own custom resolver implementation for mobile apps. There is no default resolver that automatically fetches device data for mobile apps because this data must be retrieved from the device hardware, which can vary between devices (iOS, Android, etc.). More information available at: BankID Risk Indication BankID Api - Auth BankID Api - Sign BankID Api - Payment Resolve requirements on Auth request If you want to set the requirements on how the authentication order must be performed dynamically for each order instead of statically during startup in Program.cs , it can be done by overriding the default implementation of the IBankIdAuthRequestRequirementsResolver . public class BankIdAuthRequestDynamicRequirementsResolver : IBankIdAuthRequestRequirementsResolver { public Task<BankIdAuthRequirements> GetRequirementsAsync() { return Task.FromResult(new BankIdAuthRequirements() { RequireMrtd = true, RequirePinCode = true, RequiredPersonalIdentityNumber = new PersonalIdentityNumber(1999, 8, 7, 239, 1) }); } } services.AddTransient<IBankIdAuthRequestRequirementsResolver, BankIdAuthRequestDynamicRequirementsResolver>(); Resolve user data on Auth request BankID allows you to display a text during authentication to describe the intent. Active Login allows you to set these parameters when authenticating: UserVisibleData UserNonVisibleData UserVisibleDataFormat These can either be set as static data during startup in Program.cs or dynamically by overiding the interface IBankIdAuthRequestUserDataResolver . Sample of static text without formatting: bankId.UseAuthRequestUserData(authUserData => { authUserData.UserVisibleData = \"Login to your account at Active Login\"; }); Sample of static text with formatting: bankId.UseAuthRequestUserData(authUserData => { var message = new StringBuilder(); message.AppendLine(\"# Active Login\"); message.AppendLine(); message.AppendLine(\"Welcome to the *Active Login* demo.\"); authUserData.UserVisibleData = message.ToString(); authUserData.UserVisibleDataFormat = BankIdUserVisibleDataFormats.SimpleMarkdownV1; }); For more advanced scenarios, you can generate the user data dynamically by implementing IBankIdAuthRequestUserDataResolver : public class BankIdAuthRequestDynamicUserDataResolver : IBankIdAuthRequestUserDataResolver { public Task<BankIdAuthUserData> GetUserDataAsync(BankIdAuthRequestContext authRequestContext, HttpContext httpContext) { return Task.FromResult(new BankIdAuthUserData() { UserVisibleData = \"*Time:* \" + DateTime.Now.ToLongTimeString(), UserVisibleDataFormat = BankIdUserVisibleDataFormats.SimpleMarkdownV1 });; } } services.AddTransient<IBankIdAuthRequestUserDataResolver, BankIdAuthRequestDynamicUserDataResolver>(); Note: For sign, user data is mandatory, and therefore part of the initiate flow. Custom QR code generation By default the ActiveLogin.Authentication.BankId.QRCoder package is needed to generate QR codes using the UseQrCoderQrCodeGenerator extension method. If you wish to provide your own implementation of QR code generation simply implement the IBankIdQrCodeGenerator interface and add your implementation as a service. services.AddTransient<IBankIdQrCodeGenerator, CustomQrCodeGenerator>(); Custom browser detection and launch info The functionality provided tries to detect the device by looking at the user agent. We need to know what device is used to launch the BankId app and this differs from iOS/Android/PC/Mac. By implementing IBankIdLauncher you can customize exactly how to launch the app. It is very rare that you need to change this, but could be relevant if you use Active Login for authenticating a user in a native mobile app. services.AddTransient<IBankIdLauncher, CustomBankIdLauncher>(); By implementing IBankIdSupportedDeviceDetector you can override how the client device is detected. This info will be used by the default BankIdLauncher. services.AddTransient<IBankIdSupportedDeviceDetector, CustomBankIdSupportedDeviceDetector>(); Use UAParserDeviceDetector for device and browser detection In Active Login device and browser detection is required for example to determine which URL to use to launch the BankID app, according to the BankID Relaying party Guidelines. This logic is primarily encapsulated into IBankIdSupportedDeviceDetector . The default implementation provided in ActiveLogin.Authentication.BankId.AspNetCore is limited to supports the ~top 5 most common browsers on both iOS and Android. But since an incorrect browser detection can lead to an incorrect launch URL and result in a broken user flow, UAParserDeviceDetector in the ActiveLogin.Authentication.BankId.UAParser package should be used to support additional browsers. It has a dependency on package uap-csharp for improved user agent parsing. Shorthand for only overriding config for custom browsers If you want to support your custom app, or a third party app (like the built in browsers in Instagram, Facebook etc.) we've made it simple to support those scenarios by allowing you to specify a custom browser config. The most common scenario is that you will set the schema for the app as return URL if you detect a specific User Agent. The AddCustomBrowserByUserAgent extension method is a shorthand for adding a custom browser config for a specific user agent that overrides the return url regardless of device. In the sample below we add support for Instagram and Facebook: services .AddBankId(bankId => { // ... bankId.AddCustomBrowserByUserAgent(userAgent => userAgent.Contains(\"Instagram\"), \"instagram://\"); bankId.AddCustomBrowserByUserAgent(userAgent => userAgent.Contains(\"FBAN\") || userAgent.Contains(\"FBAV\"), \"fb://\"); // ... }); If you need, you can also specify the reload behaviour on the custom browser: services .AddBankId(bankId => { // ... bankId.AddCustomBrowserByUserAgent(userAgent => userAgent.Contains(\"Instagram\"), new BankIdLauncherUserAgentCustomBrowser(\"instagram://\", BrowserReloadBehaviourOnReturnFromBankIdApp.Never)); // ... }); If you need to do something custom, you can implement IBankIdLauncherCustomBrowser : services .AddBankId(bankId => { // ... bankId.AddCustomBrowser<BankIdFacebookAppBrowserConfig>(); // ... }); public class BankIdFacebookAppBrowserConfig : IBankIdLauncherCustomAppCallback { private readonly IHttpContextAccessor _httpContextAccessor; public BankIdFacebookAppCallback(IHttpContextAccessor httpContextAccessor) { _httpContextAccessor = httpContextAccessor; } public Task<bool> IsApplicable(BankIdLauncherCustomAppCallbackContext context) { var userAgent = _httpContextAccessor.HttpContext?.Request.Headers.UserAgent.FirstOrDefault(); if (string.IsNullOrWhiteSpace(userAgent)) { return Task.FromResult(false); } var isFacebook = userAgent.Contains(\"FBAN\") || userAgent.Contains(\"FBAV\"); return Task.FromResult(isFacebook); } public Task<string> GetCustomAppReturnUrl(BankIdLauncherCustomAppCallbackContext context) { return Task.FromResult( new BankIdLauncherCustomAppCallbackResult(\"fb://\", BrowserReloadBehaviourOnReturnFromBankIdApp.Never, BrowserMightRequireUserInteractionToLaunch.Default) ); } } Risk indication You can choose to request a risk indication from BankID for both identifications and signatures. It can be used to increase security, protect your customers and reduce the risk of fraud. The indication is categorized as low, medium or high risk. You must implement your own logic to act on the assessed risk level from BankID. You need to provide information to BankID in the auth or sign request, to help them make the risk assessment e.g. the end users IP address and the app or web property (which is part of Device Data in Active Login). Incorrect information in the call gives an incorrect risk indication. Use the BankID option below to turn on risk indication. Read more about Customizing BankID options . services.Configure<BankIdAuthOptions>(options => { options.BankIdReturnRisk = true; }); To get risk indication extracted from the completion data returned by BankID and issued as a claim from Active Login create your own claims transformer . public class BankIdTxnClaimsTransformer : IBankIdClaimsTransformer { public Task TransformClaims(BankIdClaimsTransformationContext context) { if (context.BankIdCompletionData != null && context.BankIdCompletionData.Risk != null) context.AddClaim(\"user_risk\", context.BankIdCompletionData.Risk); return Task.CompletedTask; } } More information available at: BankID Risk Indication Verify digital ID card To use the API for \"Verify digital ID card\" you first need to register the BankID services, select an environment etc. services .AddBankId(bankId => { bankId .AddDebugEventListener() .UseTestEnvironment(); }); Then you can use the Verify API from, for example, an MVC Controller. The API allows you to send in the content of the QR-code and responds with the verification details. In the example below the client (HTML/JS for example) have already decoded the QR-code. public class VerifyRequestModel { public string QrCodeContent { get; set; } = string.Empty; } public class VerifyController : Controller { private readonly IBankIdVerifyApiClient _bankIdVerifyApiClient; public VerifyController(IBankIdVerifyApiClient bankIdVerifyApiClient) { _bankIdVerifyApiClient = bankIdVerifyApiClient; } [HttpPost(\"/verify/api\")] public async Task<ActionResult<string>> Verify([FromBody] VerifyRequestModel model) { // Minimalistic sample implementation ArgumentNullException.ThrowIfNull(model, nameof(model)); if (string.IsNullOrEmpty(model.QrCodeContent)) { throw new ArgumentNullException(nameof(model.QrCodeContent)); } var verifyResult = await _bankIdVerifyApiClient.VerifyAsync(model.QrCodeContent); return verifyResult.User.PersonalIdentityNumber; } } Use api wrapper only We have seperated the API-wrapper for BankID into a separate package so that you can use it in other scenarios we have not covered. They look like this and are both well documented using XML-comments. The constructor for these ApiClients takes an HttpClient and you need to configure that HttpClient with a BaseAddress , Tls12 , client certificates etc. depending on your needs. For easy use the APIs you register the BankID services, select an environment etc. and then the APIs are ready to be injected using IoC. services .AddBankId(bankId => { bankId .AddDebugEventListener() .UseTestEnvironment(); }); Note: The BankIdApiClient class below is available in the ActiveLogin.Authentication.BankId.Api package. App API: public class BankIdAppApiClient : IBankIdAppApiClient { public Task<AuthResponse> AuthAsync(AuthRequest request) { ... } public Task<SignResponse> SignAsync(SignRequest request) { ... } public Task<PaymentResponse> PaymentAsync(PaymentRequest request) { ... } public Task<PhoneAuthResponse> PhoneAuthAsync(PhoneAuthRequest request) { ... } public Task<PhoneSignResponse> PhoneSignAsync(PhoneSignRequest request) { ... } public Task<CollectResponse> CollectAsync(CollectRequest request) { ... } public Task<CancelResponse> CancelAsync(CancelRequest request) { ... } } Verify API: public class BankIdVerifyApiClient : IBankIdVerifyApiClient { public Task<VerifyResponse> VerifyAsync(VerifyRequest request) { ... } } Localization The messages are already localized to English and Swedish using the official recommended texts. To select what language that is used you can for example use the localization middleware in ASP.NET Core . The user messages that will be displayed are provided through the implementation of IBankIdUserMessageLocalizer , so by overriding this you can customize the messages. services.AddTransient<IBankIdUserMessageLocalizer, CustomBankIdUserMessageLocalizer>(); Names of the person might be capitalized The names comes from the bank that the end user has, and some banks (due to legacy) stores all of the names in all caps (like ALICE SMITH ). We have choosen not to normalize the capitalization of the names as it´s hard or impossible to do so in a general way. Cookies issued The *.AspNetCore package will issue a cookie to make the auth flow work Cookie: __ActiveLogin.BankIdUiState This cookie is there to store state during the auth process, as the user will/might be redirected during the flow. The cookie is session based only and will be deleted once the auth process is finished and/or when the user closes the browser. Because it is strictly related to temp storage during auth, you should not have to inform the user about these specific cookies (according to the EU \"cookie law\" ). With the current implementation (following the convention from Microsoft ASP.NET) the usage of cookies is not optional. A more technical deep dive of this cookie can be found in this issue . Cookie: __ActiveLogin.BankIdDeviceData This cookie is used to store the device data for the user, in the default implementation, it is used to ensure that the device data is persistent across requests. Note: All cookies issued by this package are protected using ASP.NET Core Data Protection . This means their contents are encrypted and tamper-proof. In certain environments (such as multi-instance deployments or containers) you may need to configure Data Protection to use a persistent key store (e.g., a shared file system, Azure Blob Storage, Redis, or SQL Server) so that cookies can be unprotected across app restarts or multiple instances. For guidance on configuring a persistent key store, see the official documentation: Data Protection configuration overview . Browser support We aim at supporting the latest version of all major browsers both on desktop and on mobile. All browsers on mobile are supported to show the UI, but the redirect flow have been tested and verified on these: iOS Safari Chrome Edge Firefox Opera Touch Android Chrome Firefox Edge Samsung Internet Opera Mini Note: Brave on iOS/Android identifies as Safari or Chrome for privacy reasons and will get wrong configuration, so the redirect flow will fail. Note: If you aim to support IE11 a polyfill for some JavaScript features we are using is needed. Fetch : https://github.com/github/fetch"
  },
  "articles/bankid-architechture.html": {
    "href": "articles/bankid-architechture.html",
    "title": "ActiveLogin.Authentication.BankId Architechture | Active Login",
    "keywords": "ActiveLogin.Authentication.BankId Architechture This document is aimed towards you who want to understand how ActiveLogin.Authentication.BankId works internally. This might be relevant if you want to contribute or review our code. The document isn't complete, but we try to write a note on the most important concepts. Auth The BanKID authentication implementation follows the standardized way of implementing an authentication provider in ASP.NET. As BankID requires us to display UI, we provide a built in one using the technique available throug Razor Class Libraries. Even though this UI is hosted as part of the application, from the authentication point of view, we treat it as a RemoteAuthenticationProvider as we need to redirect the user to such this UI and wait for the user to complete the auth flow. During the flow state is protected and stored in the quesy string and in a cookie. Auth Flow AuthenticationBuilderBankIdAuthExtensions AddBankIdAuth() Adds default implementations to IoC Adds ASP.NET Core authentication configuration Runs the IBankIdAuthBuilder pipeline BankIdAuthBuilderExtensions Add* Allows for adding schemes with relevant configuration for Same or Other device BankIdAuthHandler Inherits the RemoteAuthenticationHandler and therefore implements the IAuthenticationHandler BankIdUiAuthController Handles the UI for auth using MVC BankIdUiAuthApiController Handles the backend calls from the UI for init/statusd/cancel etc. graph TD App-->A A[AccountController.Login] -->B B[AccountController.ExternalLogin] -->|Challange|C C[BankIdUiAuthController.Init] --> D D([BankIdUiAuth/Init.cshtml]) E[BankIdUiAuthApiController.Initialize] F[BankIdUiAuthApiController.QrCode]-->D G[BankIdUiAuthApiController.Status]-->D D-->E D-->F D-->G D-->H H[AccountController.ExternalLoginCallback] -->|HttpContext.AuthenticateAsync|App Sign When we implemented BankId Auth we simply follow the concept and conventions Microsoft have when implementing a custom authentication provider. Scheme configuration, AuthenticationHandler, Challange, Claims etc. Sign is not such a common concept the therefore the underlying infrastructure is not there. We've tried to use the same basic concepts, but simplified (as we only need to support our own scenario). Sign Flow ServiceCollectionBankIdSignExtensions AddBankIdSign() Adds default implementations to IoC Adds ASP.NET Core configuration Runs the IBankIdSignBuilder pipeline BankIdSignBuilder AddConfig Similar to AddScheme with the difference that it does not register a callback URL, this is instead specified on the call to InitiateSign on BankIdSignService Will register the config in the IBankIdSignConfigurationProvider IBankIdSignConfigurationProvider Keeps a list of the registered BankIdSignConfiguration BankIdSignService Allows for inittiating the Sign flow and redirecting the user to the correct page Handles the callback when sign is done Get state from cookie, return to the url specified by consumer BankIdUiSignController Handles the UI for sign using MVC BankIdUiSignApiController Handles the backend calls from the UI for init/statusd/cancel etc. graph TD App-->A A[SignController.Index] -->B B[SignController.Sign] -->|IBankIdSignService.InitiateSignAsync|C C[BankIdUiSignController.Init] --> D D([BankIdUiSign/Init.cshtml]) E[BankIdUiSignApiController.Initialize] F[BankIdUiSignApiController.QrCode]-->D G[BankIdUiSignApiController.Status]-->D D-->E D-->F D-->G D-->H H[SignController.Callback] -->|IBankIdSignService.GetSignResultAsync|App"
  },
  "articles/BREAKINGCHANGES.html": {
    "href": "articles/BREAKINGCHANGES.html",
    "title": "Breaking changes in Active Login Authentication | Active Login",
    "keywords": "Breaking changes in Active Login Authentication Here we try to make a summary of the major breaking changes in things that you as a consumer of Active Login can use/extend/implement. Note: We might, and will probably, miss to document some of this - if so - please make a PR to this file and add a note on such breaking change. TOC Version 11.0.0 Version 10.0.0 Version 9.0.0 Version 8.0.0 Version 7.0.0 Version 6.0.3 Version 6.0.0 Version 5.0.0 Version 4.0.0 Version 11.0.0 Breaking changes between version 11.0.0 and 10.0.0 Remove allowed risk Level Removed support for blocking auth and sign transactions based on risk level, since no longer supported by BankID. services.Configure<BankIdAuthOptions>(options => { options.BankIdAllowedRiskLevel = BankIdAllowedRiskLevel.Low; }); Use return risk instead and handle risk level in your application. services.Configure<BankIdAuthOptions>(options => { options.BankIdReturnRisk = true; }); BankID provides futher information more about Risk Indication . Version 10.1.0 Important Note Version 10.1.0 was released as a minor version and should not have introduced breaking changes. However, in practice, some users experienced issues related to the new cookie __ActiveLogin.BankIdDeviceData . If you encountered issues after upgrading, please review the guidance below. Added New Cookie for Device Data A new Cookie __ActiveLogin.BankIdDeviceData was added to store information about the end user’s device. This information is sent to BankID and used for risk indication. The cookie is long lived and persisted across sessions. Since all cookies issued by Active Login are protected using ASP.NET Core Data Protection. In certain environments (such as multi-instance deployments or containers) you may need to configure Data Protection to use a persistent key store (e.g. a shared file system, Azure Blob Storage, Redis, or SQL Server) so that cookies can be unprotected across app restarts or multiple instances. This applies also to the existing UI State cookie in Active Login. However, since that cookie has a very short lifetime compared to the device data cookie, the risk of running in to issues related to data protection is significantly lower for that cookie. For guidance on configuring a persistent key store, see the official documentation: Data Protection configuration overview . Version 10.0.0 Breaking changes between version 10.0.0 and 9.0.0 Policy handling Remove policy handling from API library into Core Fall back to mobile BankID policy for OtherDevice flow Enum for setting policy instead of string Replaced Embedded BankID Certificate for Test Environment Replace embedded BankID certificate for the test environment FPTestcert4_20220818.p12, with the three new versions of the client certificate FPTestcert5_20240610.p12, FPTestcert5_20240610.pem and FPTestcert5_20240610-legacy.pfx. Make it configurable which version to use. For compatibility reasons use FPTestcert5_20240610-legacy.pfx by default. Version 9.0.0 Breaking changes between version 9.0.0 and 8.0.0 Remove callInitiator from CollectResponse as it's not documented anymore Rename CollectCallInitiator into CallInitiator Version 8.0.0 Breaking changes between version 8.0.0 and 7.0.0 IBankIdLauncherCustomAppCallback becomes IBankIdLauncherCustomBrowser We have broadedned the scope of the interface IBankIdLauncherCustomAppCallback to IBankIdLauncherCustomBrowser to allow for more flexibility in the implementation. We have renamed these things as a result of that: IBankIdLauncherCustomAppCallback becomes IBankIdLauncherCustomBrowser AddCustomAppCallback becomes AddCustomBrowser AddCustomAppCallbackByUserAgent becomes AddCustomBrowserByUserAgent Upgrade to .NET 7 We now require .NET 8 - so this requires you to upgrade your website that uses Active Login. Version 7.0.0 Breaking changes between version 7.0.0 and 6.0.3 Upgrade to .NET 7 We now require .NET 7 - so this requires you to upgrade your website that uses Active Login. API changes The API has changed to reflect the new BankID API (v 6.0). An overview of those changes can be found in this issue . Rename API Wrapper As we've added support for the new Verify API, we have renamed the existing API into App API. These changes should go unnoticed for most of you if you are using the high level abstractions. IBankIdApiClient is renamed into IBankIdAppApiClient BankIdApiClient is renamed into BankIdAppApiClient BankIdSimulatedApiClient is renamed into BankIdSimulatedAppApiClient BankIdSimulatedApiClient is renamed into BankIdSimulatedAppApiClient BankIdApiClientExtensions is renamed into BankIdAppApiClientExtensions Custom options Some API changes (as described above) propagates to the options you can customize per authentication scheme. The following options have been changed: BankIdAllowBiometric is removed and replaced by BankIdRequirePinCode . This has the opposite meaning as the old option, so be sure to update your code if you have used this. IBankIdLauncher.GetLaunchInfo is now async The method GetLaunchInfo on IBankIdLauncher is now renamed into GetLaunchInfoAsync and made async to allow for dynamic retreival. Version 6.0.3 Breaking changes in 6.0.3: As stated in #384 we had mixed up the UseClientCertificate() and AddClientCertificate() extension methods. These have now been reversed. This would be a breaking change if you add multiple certificates but should affect the majority of consumers. Version 6.0.0 Breaking changes between version 5.0.0 and 6.0.0. Note: Version is a major release with a large set of refactorings, name changes, and namespace changes. We have not covered it all, but tried to summarize the major ones below. In v6 we introduced Sign and wanted to refactor and rename things to make i consistent and easy to use both/either of them. This will cause some work when upgrading from a previous version. Renaming NuGet-packages As all of the support packages related to Azure etc. now only depend on the Core package, we have renamed a few packages to reflect this: ActiveLogin.Authentication.BankId.AspNetCore.Azure is now ActiveLogin.Authentication.BankId.AzureKeyVault ActiveLogin.Authentication.BankId.AspNetCore.AzureMonitor is now ActiveLogin.Authentication.BankId.AzureMonitor ActiveLogin.Authentication.BankId.AspNetCore.QRCoder is now ActiveLogin.Authentication.BankId.QRCoder ActiveLogin.Authentication.BankId.AspNetCore.UAParser is now ActiveLogin.Authentication.BankId.UAParser Auth functionality is now separate from core functionality This means that you need to register the common configuration first and then the auth specific conf, like this: services .AddBankId(bankId => { bankId.UseQrCoderQrCodeGenerator(); bankId.UseUaParserDeviceDetection(); ... }); services.AddAuthentication() .AddCookie() .AddBankIdAuth(bankId => { bankId.AddSameDevice(); bankId.AddOtherDevice(); }); Moving extension methods away from Microsoft.Extensions.DependencyInjection As per the Microsoft guideline about namespaces in libraries, we have moved our extension methods away from Microsoft.Extensions.DependencyInjection into their \"natural\" namespaces. This means that in your Program.cs you might need to import these namespaces: using ActiveLogin.Authentication.BankId.AspNetCore.Auth; using ActiveLogin.Authentication.BankId.AspNetCore.Sign; using ActiveLogin.Authentication.BankId.AzureKeyVault; using ActiveLogin.Authentication.BankId.AzureMonitor; using ActiveLogin.Authentication.BankId.Core; using ActiveLogin.Authentication.BankId.QrCoder; using ActiveLogin.Authentication.BankId.UaParser; Requires static files The stylesheet and the javascript for the client are now served as *.css and *.js files, so you need to enable static file support. app.UseStaticFiles(); Moving core functionality to separate package Core functionality that is not tied to web (AspNetCore) is moved into a separate package called ActiveLogin.Authentication.BankId.Core . If you directly use/extend/implement anything related to these areas you might have to update your references: IBankIdEndUserIpResolver IBankIdLauncher IBankIdResultStore IBankIdQrCodeGenerator IBankIdSupportedDeviceDetector IBankIdAuthRequestUserDataResolver IBankIdUserMessageLocalizer Events Renaming area and URL:s The area and URL:s used internally are now renamed: /BankIdAuthentication/BankId/Login is now /ActiveLogin/BankId/Auth /BankIdAuthentication/BankId/Api/* is now /ActiveLogin/BankId/Api/* Renaming views These views have been renamed: Login.cshtml is now Init.cshtml _Login.cshtml is now _Wrapper.cshtml _LoginForm.cshtml is now _Form.cshtml _LoginStatus.cshtml is now _Status.cshtml _LoginScript.cshtml is now _Script.cshtml _LoginStyle.cshtml is now _Style.cshtml _spinner.cshtml is now _Spinner.cshtml Note: As the area and controller have been renamed these files should now be placed in /Areas/ActiveLogin/Views/BankIdUiAuth/ or /Areas/ActiveLogin/Views/Shared/ . Note: Both the html, css and javascript have breaking changes. See history for respective file for exact changes. Renaming BankIdDefaults BankIdDefaults have been renamed into BankIdAuthDefaults and can now be found in the namespace ActiveLogin.Authentication.BankId.AspNetCore.Auth . The default values for SameDeviceAuthenticationScheme , OtherDeviceAuthenticationScheme , SameDeviceCallbackPath and OtherDeviceCallbackPath have also changed. Removing dependency on HttpContext in ActiveLogin.Authentication.BankId.Core No classes or interfaces in ActiveLogin.Authentication.BankId.Core will have a dependency on ``HttpContext . HttpContext would previously be passed as arguments to some methods defined in our interfaces. If you need HttpContext for your implementation, take a dependency on IHttpContextAccessor` to achieve the same functionality - this is how we solve it internally as well. Name changes for *Login To reflect that we now support both auth and sign we have renamed a lot of classes called something with Login . For example: BankIdLoginResult is now BankIdUiResult BankIdLoginOptions is now BankIdUiOptions Renaming metadata for Azure Monitor These properties have been renamed: AL_BankId_LoginOptions_LaunchType is now AL_BankId_Options_LaunchType AL_BankId_LoginOptions_UseQrCode is now AL_BankId_Options_UseQrCode BankIdDynamicEndUserIpResolver removed BankIdDynamicEndUserIpResolver removed is now removed. It was a shorthand for a scenario that should be very uncommon. lease use BankIdRemoteIpAddressEndUserIpResolver instead if you need to override end user ip retrieval. No manual input of PersonalIdentityNumber The use of personalIdentityNumber in the auth flow is no longer supported as BankID recommends to only using either animated QR codes or autostarttoken on the same device. Multi tenant If you register multiple client certificates (multi-tenant scenarios) you now need to use the .AddClientCertificate...() methods instead of .UseClientCertificate...() . .UseClientCertificate...() will remove any previously registered certificates. This applies to: .AddClientCertificate() .AddClientCertificateFromAzureKeyVault() Application Insights Connection String instead of Instrumentation Key When using Application Insights you should nowadays specify a connection string instead of just an instrumentation key . We've updated our methods that explicitly took an instrumentation key to instead take a connection string. This applies to: AddApplicationInsightsEventListener() Version 5.0.0 Breaking changes between version 4.0.0 and 5.0.0 Upgrade to .NET 6 We now require .NET 6 for the UI parts - so this requires you to upgrade your website that uses Active Login. Support BankID animated QR code in UI When implementing the animated QR code, we have had to update the client side script in LoginScript.cshtml . Look at the Git history for this file if you want to see the exact changes. This is only a breaking change if you have overridden this file with your own imlpementation. Use DefaultAzureCredentials when accessing KeyVault If using Azure KeyVault for your certificate, we have made chamges to how you authenticate/access that. See the documention for how it should be configured now. Drop support for GrandID When we created Active Login we added support for BankID directly as well as through Svensk E-identitet (GrandID). At the time we had cases where we were using both so it was natural to support them both. As time has gone by we see that basically, all new cases for us use the \"native\" BankID provider so that's where we have focused our efforts in Active Login. We have reached the point where it is not possible for us to support the GrandId packages anymore as part of this open-source project. In the end, we have just so much time that we want to spend where we think it benefits the most users, and the download counts on NuGet tell this is the native BankID parts. See more details in this announcement . Issue correct exp claim We previously issued an incorrect exp claim. This is now issued correctly, but might be a breaking change for you. Remove built in support for Birthdate and Gender claim The Birthdate and Gender claim are not issued by the library, but we have added docs on how to issue them yourself. Version 4.0.0 Breaking changes between version 3.0.0 and 4.0.0 Renaming events We have renamed events and event ids but the log messages should be the same. A full list of current event names and ids can be found in BankIdEventTypes.cs . The category of events logged to ILogger will now be BankIdLoggerEventListener . Removed UseClientCertificateResolver The UseClientCertificateResolver extension was removed, but docs was added with sample on how to achieve the same result. Refactor IBankIdLauncher IBankIdLauncher was refactored to return an object with launch info, not only launch URL."
  },
  "articles/CODE_OF_CONDUCT.html": {
    "href": "articles/CODE_OF_CONDUCT.html",
    "title": "Contributor Covenant Code of Conduct | Active Login",
    "keywords": "Contributor Covenant Code of Conduct Our Pledge In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, gender identity and expression, level of experience, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at activelogin@activesolution.se. The project team will review and investigate all complaints, and will respond in a way that it deems appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at http://contributor-covenant.org/version/1/4"
  },
  "articles/CONTRIBUTING.html": {
    "href": "articles/CONTRIBUTING.html",
    "title": "Contributing to Active Login | Active Login",
    "keywords": "Contributing to Active Login We are very open to community contributions to Active Login. You'll need a basic understanding of Git and GitHub to get started. Ways to contribute You can contribute in many different ways, for example: Find bugs and file issues Write documentation Add features Write tests Join in on discussions Contributing code Remember, if you contribute to code, always follow this: File an issue according to our templates. Describe what you want to do and get our feedback before starting to code. Write relevant tests for your code. Update documentation when relevant. Make a PR. We might (and probably will) reject PR:s that does not follow the requirements above. Discussion You can join our discussions on GitHub Discussions to discuss ideas and get early feedback:"
  },
  "articles/LICENSE.html": {
    "href": "articles/LICENSE.html",
    "title": "| Active Login",
    "keywords": "MIT License Copyright (c) 2018-2023 Active Solution Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE."
  },
  "articles/monitor.html": {
    "href": "articles/monitor.html",
    "title": "Active Login Monitor | Active Login",
    "keywords": "Active Login Monitor When using the BankIdApplicationInsightsEventListener ( bankId.AddApplicationInsightsEventListener() ) structured events from the Active Login flow will be published to Application Insights (Azure Monitor). Below are samples on how to query these using KQL . Dashboard In our provisioning samples we include a way to deploy an Azure Dashboard displaying some of the most important metrics and queries from below. See ActiveLogin-Monitor.json . <!--(/samples/AzureProvisioningSample/ActiveLogin-Monitor.json)--> KQL Samples All info customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, client_City, client_CountryOrRegion, Event_Name = name, Event_TypeId = tostring(customDimensions.AL_Event_TypeId), Event_Severity = tostring(customDimensions.AL_Event_Severity), Error_ErrorReason = tostring(customDimensions.AL_Error_ErrorReason), BankId_BankId_Options_LaunchType = tostring(customDimensions.AL_BankId_Options_LaunchType), BankId_Options_UseQrCode = tostring(customDimensions.AL_BankId_Options_UseQrCode), BankId_ErrorCode = tostring(customDimensions.AL_BankId_ErrorCode), BankId_ErrorDetails = tostring(customDimensions.AL_BankId_ErrorDetails), BankId_OrderRef = tostring(customDimensions.AL_BankId_OrderRef), BankId_CollectHintCode = tostring(customDimensions.AL_BankId_CollectHintCode), BankId_User_CertNotBefore = tostring(customDimensions.AL_BankId_User_CertNotBefore), BankId_User_CertNotAfter = tostring(customDimensions.AL_BankId_User_CertNotAfter), BankId_User_DeviceIpAddress = tostring(customDimensions.AL_BankId_User_DeviceIpAddress), User_Device_Browser = tostring(customDimensions.AL_User_Device_Browser), User_Device_Os = tostring(customDimensions.AL_User_Device_Os), User_Device_Type = tostring(customDimensions.AL_User_Device_Type), User_Device_OsVersion = tostring(customDimensions.AL_User_Device_OsVersion), User_Name = tostring(customDimensions.AL_User_Name), User_GivenName = tostring(customDimensions.AL_User_GivenName), User_Surname = tostring(customDimensions.AL_User_Surname), User_SwedishPersonalIdentityNumber = tostring(customDimensions.AL_User_SwedishPersonalIdentityNumber), User_DateOfBirthHint = tostring(customDimensions.AL_User_DateOfBirthHint), User_AgeHint = tostring(customDimensions.AL_User_AgeHint), User_GenderHint = tostring(customDimensions.AL_User_GenderHint), ProductName = tostring(customDimensions.AL_ProductName), ProductVersion = tostring(customDimensions.AL_ProductVersion), BankId_ApiEnvironment = tostring(customDimensions.AL_BankId_ApiEnvironment), BankId_ApiVersion = tostring(customDimensions.AL_BankId_ApiVersion) | order by timestamp desc | render table Metadata Active Login Version customEvents | where name == \"ActiveLogin_BankId_AspNetChallengeSuccess\" | project ActiveLogin_ProductVersion = tostring(customDimensions.AL_ProductVersion) | summarize count() by ActiveLogin_ProductVersion | render piechart Launch Type (SameDevice / OtherDevice) customEvents | where name == \"ActiveLogin_BankId_AspNetChallengeSuccess\" | project LaunchType = tostring(customDimensions.AL_BankId_Options_LaunchType) | summarize count() by LaunchType | render piechart Device Type (SameDevice / OtherDevice) customEvents | where name == \"ActiveLogin_BankId_AspNetChallengeSuccess\" | project DeviceType = tostring(customDimensions.AL_User_Device_Type) | summarize count() by DeviceType | render piechart Launch Type and Device Type customEvents | where name == \"ActiveLogin_BankId_AspNetChallengeSuccess\" | project DeviceType = tostring(customDimensions.AL_User_Device_Type), LaunchType = tostring(customDimensions.AL_BankId_Options_LaunchType) | project DeviceTypeAndLaunchType = strcat(DeviceType, ' - ', LaunchType) | summarize count() by DeviceTypeAndLaunchType | render piechart Device Type and Device OS customEvents | where name == \"ActiveLogin_BankId_AspNetChallengeSuccess\" | project DeviceType = tostring(customDimensions.AL_User_Device_Type), DeviceOs = tostring(customDimensions.AL_User_Device_Os) | project DeviceAndDeviceOs = strcat(DeviceType, ' - ', DeviceOs) | summarize count() by DeviceAndDeviceOs | render piechart Device OS and Device Browser customEvents | where name == \"ActiveLogin_BankId_AspNetChallengeSuccess\" | project DeviceOs = tostring(customDimensions.AL_User_Device_Os), DeviceBrowser = tostring(customDimensions.AL_User_Device_Browser) | project DeviceOsAndDeviceBrowser = strcat(DeviceOs, ' - ', DeviceBrowser) | summarize count() by DeviceOsAndDeviceBrowser | render piechart Average age customEvents | where name == \"ActiveLogin_BankId_CollectCompleted\" | project UserAgeHint = toint(customMeasurements.AL_User_AgeHint) | summarize AverageUserAge = avg(UserAgeHint) Success Succesful logins chart customEvents | where name == \"ActiveLogin_BankId_AspNetAuthenticateSuccess\" | project timestamp | summarize Logins = count() by bin(timestamp, 1d) | render columnchart Succesful logins by week customEvents | where name == \"ActiveLogin_BankId_AspNetAuthenticateSuccess\" | project timestamp, Year = datetime_part(\"Year\", timestamp), Week = week_of_year(timestamp) | extend YearAndWeek = strcat(Year, ' ' , Week) | order by Year, Week | summarize Logins = count() by YearAndWeek | render table Succesful logins by month let MonthNames = dynamic([\"\", \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"]); customEvents | where name == \"ActiveLogin_BankId_AspNetAuthenticateSuccess\" | project timestamp, Year = datetime_part(\"Year\", timestamp), Month = datetime_part(\"Month\", timestamp) | extend YearAndMonth = strcat(Year, ' ' , tostring(MonthNames[Month])) | order by Year, Month | summarize Logins = count() by YearAndMonth | render table Success details customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, Event_ShortName = substring(name, 19), Event_TypeId = tostring(customDimensions.AL_Event_TypeId), Event_Severity = tostring(customDimensions.AL_Event_Severity), BankId_Options_LaunchType = tostring(customDimensions.AL_BankId_Options_LaunchType), BankId_Options_UseQrCode = tostring(customDimensions.AL_BankId_Options_UseQrCode), BankId_OrderRef = tostring(customDimensions.AL_BankId_OrderRef), BankId_CollectHintCode = tostring(customDimensions.AL_BankId_CollectHintCode), BankId_User_CertNotBefore = tostring(customDimensions.AL_BankId_User_CertNotBefore), BankId_User_CertNotAfter = tostring(customDimensions.AL_BankId_User_CertNotAfter), BankId_User_DeviceIpAddress = tostring(customDimensions.AL_BankId_User_DeviceIpAddress), User_Device_Browser = tostring(customDimensions.AL_User_Device_Browser), User_Device_Os = tostring(customDimensions.AL_User_Device_Os), User_Device_Type = tostring(customDimensions.AL_User_Device_Type), User_Device_OsVersion = tostring(customDimensions.AL_User_Device_OsVersion), User_Name = tostring(customDimensions.AL_User_Name), User_GivenName = tostring(customDimensions.AL_User_GivenName), User_Surname = tostring(customDimensions.AL_User_Surname), User_SwedishPersonalIdentityNumber = tostring(customDimensions.AL_User_SwedishPersonalIdentityNumber), User_DateOfBirthHint = tostring(customDimensions.AL_User_DateOfBirthHint), User_AgeHint = tostring(customDimensions.AL_User_AgeHint), User_GenderHint = tostring(customDimensions.AL_User_GenderHint), ProductName = tostring(customDimensions.AL_ProductName), ProductVersion = tostring(customDimensions.AL_ProductVersion), BankId_ApiEnvironment = tostring(customDimensions.AL_BankId_ApiEnvironment), BankId_ApiVersion = tostring(customDimensions.AL_BankId_ApiVersion) | where Event_Severity == \"Success\" | order by timestamp desc | render table Errors Error chart - By event and error code customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, Event_ShortName = substring(name, 19), BankId_ErrorCode = tostring(customDimensions.AL_BankId_ErrorCode), EventSeverity = tostring(customDimensions.AL_Event_Severity) | where EventSeverity == \"Failure\" or EventSeverity == \"Error\" | extend EventAndErrorCode = strcat(Event_ShortName, ' - ', BankId_ErrorCode) | summarize count() by bin(timestamp, 1d), EventAndErrorCode | render columnchart Error chart - By error code customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, ErrorCode = tostring(customDimensions.AL_BankId_ErrorCode), EventSeverity = tostring(customDimensions.AL_Event_Severity) | where EventSeverity == \"Failure\" or EventSeverity == \"Error\" | summarize count() by bin(timestamp, 1d), ErrorCode | render columnchart Error details customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, Event_ShortName = substring(name, 19), Event_TypeId = tostring(customDimensions.AL_Event_TypeId), Event_Severity = tostring(customDimensions.AL_Event_Severity), Error_ErrorReason = tostring(customDimensions.AL_Error_ErrorReason), BankId_Options_LaunchType = tostring(customDimensions.AL_BankId_Options_LaunchType), BankId_Options_UseQrCode = tostring(customDimensions.AL_BankId_Options_UseQrCode), BankId_ErrorCode = tostring(customDimensions.AL_BankId_ErrorCode), BankId_ErrorDetails = tostring(customDimensions.AL_BankId_ErrorDetails), BankId_OrderRef = tostring(customDimensions.AL_BankId_OrderRef), BankId_CollectHintCode = tostring(customDimensions.AL_BankId_CollectHintCode), BankId_User_CertNotBefore = tostring(customDimensions.AL_BankId_User_CertNotBefore), BankId_User_CertNotAfter = tostring(customDimensions.AL_BankId_User_CertNotAfter), BankId_User_DeviceIpAddress = tostring(customDimensions.AL_BankId_User_DeviceIpAddress), User_Device_Browser = tostring(customDimensions.AL_User_Device_Browser), User_Device_Os = tostring(customDimensions.AL_User_Device_Os), User_Device_Type = tostring(customDimensions.AL_User_Device_Type), User_Device_OsVersion = tostring(customDimensions.AL_User_Device_OsVersion), User_Name = tostring(customDimensions.AL_User_Name), User_GivenName = tostring(customDimensions.AL_User_GivenName), User_Surname = tostring(customDimensions.AL_User_Surname), User_SwedishPersonalIdentityNumber = tostring(customDimensions.AL_User_SwedishPersonalIdentityNumber), User_DateOfBirthHint = tostring(customDimensions.AL_User_DateOfBirthHint), User_AgeHint = tostring(customDimensions.AL_User_AgeHint), User_GenderHint = tostring(customDimensions.AL_User_GenderHint), ProductName = tostring(customDimensions.AL_ProductName), ProductVersion = tostring(customDimensions.AL_ProductVersion), BankId_ApiEnvironment = tostring(customDimensions.AL_BankId_ApiEnvironment), BankId_ApiVersion = tostring(customDimensions.AL_BankId_ApiVersion) | where Event_Severity == \"Failure\" or Event_Severity == \"Error\" | order by timestamp desc | render table Errors by error code customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, ErrorCode = tostring(customDimensions.AL_BankId_ErrorCode), EventSeverity = tostring(customDimensions.AL_Event_Severity) | where EventSeverity == \"Failure\" or EventSeverity == \"Error\" | summarize count() by ErrorCode | render piechart Errors by type customEvents | where name startswith \"ActiveLogin_BankId_\" | project Event_ShortName = substring(name, 19), Event_Severity = tostring(customDimensions.AL_Event_Severity) | where Event_Severity == \"Failure\" or Event_Severity == \"Error\" | summarize count() by Event_ShortName | render piechart Events Events by severity customEvents | where name startswith \"ActiveLogin_BankId_\" | project timestamp, Severity = tostring(customDimensions.AL_Event_Severity) | summarize count() by bin(timestamp, 1d), Severity | render columnchart"
  },
  "articles/README.html": {
    "href": "articles/README.html",
    "title": "ActiveLogin.Authentication | Active Login",
    "keywords": "ActiveLogin.Authentication ActiveLogin.Authentication enables an application to support Swedish BankID (svenskt BankID) authentication in .NET. Active Login is licensed is provided under the very permissive MIT license for you to be able to use it in commercial or non-commercial applications without many restrictions. Active Login is provided \"as is\", without any warrany of any kind. If you need support, commercial support and training is available. Active Login is not a product created by BankID. It is an unofficial project that was developed by Active Solution. All trademarks are the property of their respective owners. Features 🆔 Supports BankID Auth (API, Flow and UI) 📝 Supports BankID Sign (API, Flow and UI) ☎️:id: Supports BankID Phone Auth (API) ☎️:pencil: Supports BankID Phone Sign (API) ☺️ Supports BankID Verify digital ID card (API) 🐧 Cross platform: Targets .NET Standard 2.0 and .NET 8 6️⃣ Built on V6.0 (the latest) BankID JSON API 🏁 Supports BankID animated QR code (Secure start) ☁️ Designed with Microsoft Azure in mind (KeyVault, Monitor, Application Insights, AD B2C etc.) 🌎 Multi language support with English and Swedish out of the box 🔧 Customizable and extensible 💠 Can be used as a Custom Identity Provider for Azure AD B2C Screenshots Screenshots on how the default UI for Native BankID looks on different devices. Screenshot on monitoring dashboard. Table of contents Note: This Readme reflects the state of our main branch and the code documented here might not be released as packages on NuGet.org yet. For early access, see our CI builds . ActiveLogin.Authentication Features Screenshots Table of contents Projects & Packages overview Usage & Docs Samples Tests FAQ What version of .NET is supported? How do I build the solution locally? Devcontainer and GitHub Codespaces How do I run the samples locally? How do I use Active Login to get support for BankID in Azure AD (Active Directory) B2C? Active Login Security Contribute Contributors Stay updated and join the discussion License Acknowledgements Sponsors Support & Training Projects & Packages overview CI-builds from main of all packages are available in our GitHub Packages feed . Project Description NuGet Downloads BankId.Api API client for the Swedish BankID REST API. BankId.Core Core functionality for the BankID flow. BankId.AspNetCore ASP.NET authentication module for Swedish BankID. BankId.AzureKeyVault Azure KeyVault integrations for the AspNetCore package. BankId.AzureMonitor Azure Monitor (Application Insights) integrations for the AspNetCore package. BankId.QRCoder QR code generation using QRCoder the AspNetCore package. BankId.UAParser Device and browser detection using UAParser. Usage & Docs Full documentation with step by step instructions, samples, customization and details on how to configure the options is available here: Documentation for ActiveLogin.Authentication.BankID Active Login is designed to make it easy to get started with BankID in .NET. The most basic setup looks like this: // Common services .AddBankId(bankId => { bankId.UseTestEnvironment(); }); // Auth services .AddAuthentication() .AddBankIdAuth(bankId => { bankId.AddSameDevice(); }); // Sign services .AddBankIdSign(bankId => { bankId.AddSameDevice(); }); Samples For more use cases, samples and inspiration; feel free to browse our unit tests and samples . Note: These are samples on how to use Active Login in different situations and might not represent optimal way of setting up ASP.NET MVC, IdentityServer or other components. Please see them as inspiration. Project Description IdentityServer.ClientSample ASP.NET MVC site using the IdentityServer.ServerSample as auth provider. IdentityServer.ServerSample IdentityServer with Active Login as auth provider for BankID. Standalone.MvcSample ASP.NET MVC with Active Login as auth provider for BankID. Also demo of Sign. AzureProvisioningSample ARM template with Azure KeyVault, Azure App Service, Azure Monitor / Application Insights etc. Phone.ConsoleSample Console application with a simple Phone Auth/Sign example Please note that IdentityServer.ClientSample uses IdentityServer.ServerSample as the IdentityProvider, so the IdentityServer.ClientSample is a good place to start. A live demo is available at https://demo.activelogin.net/ . Tests BankId.Api.Test BankId.Core.Test BankId.AspNetCore.Test BankId.UAParser.Test BankId.AzureKeyVault.Test FAQ Here is a summary of common, general technical questions. The docs for ActiveLogin.Authentication.BankId contains an FAQ specific to BankID. For commercial / business related questions, see the FAQ at ActiveLogin.net . What version of .NET is supported? The API-wrapper (ActiveLogin.Authentication.BankId.Api) target .NET Standard 2.0, so it can be used from .NET >= 5.0, .NET Core >= 2.0 and .NET Framework >= 4.6.1, see full reference here . The package that target .NET Standard is strong named as it can be used from .NET Framework where strong naming can be relevant. The authentication module ( .AspNetCore), depend on ASP.NET 8 and therefore requires .NET 8. The core module ( .Core), and related packages, depend on and requires .NET 8. Our samples target .NET 8 and follow the conventions used there. How do I build the solution locally? Active Login is built using .NET, make sure you have the relevant version of the SDK and runtime installed. Run the following command in the root to build all projects: dotnet build Run the following command in the root to run all tests: dotnet test Devcontainer and GitHub Codespaces We also support devcontainer.json so that you can build the solution in a container and use GitHub Codespaces . How do I run the samples locally? The samples are configured to run for the test environment (no BankID certificate required as it's bundled with the library) by default. The Standalone.MvcSample is using the the most basic sample and is a good start. To run the sample: Navigate to /Samples/Standalone.MvcSample/ and run: dotnet run How do I use Active Login to get support for BankID in Azure AD (Active Directory) B2C? Azure AD B2C supports using custom identity providers that supports Open ID Connect . If you deploy Active Login as part of IdentityServer (see our samples) you can configure your Azure AD B2C to federate to that instance and by doing so get BankID support. Active Login Active Login is an Open Source project built on .NET that makes it easy to integrate with leading Swedish authentication services like BankID . Security In our Security Policy you can read about how to report a vulnerability, how to subscribe to security alerts and what packages we currently support. Contribute We are very open to community contributions to Active Login. Please see our contribution guidelines before getting started. Contributors Thank you to all who have and are contributing to this project! Stay updated and join the discussion The three primary ways to interact and stay updated with Active Login are: Watch our GitHub repo Interact on GitHub Discussions Follow us on Twitter License Active Login is licensed under the very permissive MIT license for you to be able to use it in commercial or non-commercial applications without many restrictions. The BankID certificates from the BankID documentation are released as part of Active Login with the permission from BankID (Finansiell ID-Teknik BID AB). All trademarks are the property of their respective owners. Acknowledgements Active Login is built on or uses the following great open source products: .NET ASP.NET XUnit QRCoder UAParser AngleSharp Moq Bootstrap Loading.io For samples, these great products are used: Duende IdentityServer Sponsors Active Solution is the main sponsor of Active Login. Active Solution is located in Sweden and provides IT consulting with focus on web, Azure and AI. Bright cloud solutions - System development that shines. Together, we create systems that will rocket your business. And yes, we are hiring 👩‍💻 :) https://www.activesolution.se/ Support & Training If you need help with implementing Active Login, there are commercial support & training options available. We can help you out with: Education and training on: Active Login IdentityServer Azure AD B2C Authentication on the .NET platform in general Hands on implementing BankID using Active Login Implement BankID as a custom Identity Provider for Azure AD B2C Continuous support for Active Login See ActiveLogin.net for more details on how to get in touch with us 📞."
  },
  "articles/SECURITY.html": {
    "href": "articles/SECURITY.html",
    "title": "Security Policy | Active Login",
    "keywords": "Security Policy Supported Versions Active Login is an open source project under the MIT-license and the software is provided \"as is\", without warranty of any kind. The work we do regarding feature updates, security patches and maintenence is focused on the latest stable of the BankID-libraries available on NuGet. If you need an SLA, support for older versions or patches to be applied to older versions we can help you on a case to case basis, see contact details under Commercial support . Reporting a Vulnerability Please report (suspected) security vulnerabilities to security@activesolution.se . You will receive a response from us as fast as possible and we will work with you to confirm the severeness of the vulnerability and get back with a plan on when a patch can be released. Note: Do not publish (suspected) security vulnerabilities publically. Subscribing to Security Alerts Any known vulnerability will be published as a Github Security Advisory under Security Advisories . By watching the repo you can make sure to be notified if anything is published there."
  },
  "index.html": {
    "href": "index.html",
    "title": "Active Login - Documentation | Active Login",
    "keywords": "@media (min-width: 768px) { .container.body-content { width: 750px; } } @media (min-width: 992px) { .container.body-content { width: 970px; } } @media (min-width: 1200px) { .container.body-content { width: 1170px; } } Active Login - Documentation ActiveLogin.Authentication enables an application to support Swedish BankID (svenskt BankID) authentication in .NET. Built on NET Standard and packaged as NuGet-packages they are easy to install and use on multiple platforms. See Articles for detailed documentation."
  }
}